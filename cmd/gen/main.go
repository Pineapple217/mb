package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/tdewolff/minify/v2"
	"github.com/tdewolff/minify/v2/css"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const folderPath = "./pkg/static"
const outputPath = folderPath + "/bundle"
const filePath = folderPath + "/file_paths.go"
const staticFiles = "./pkg/static/public"

const fileHeader = `// Code generated by ./cmd/gen - DO NOT EDIT.

package static

`

var extentions = []string{
	".css",
	".png",
	".svg",
	".ico",
}

type hashed struct {
	fileName string
	path     string
}

func main() {
	if err := os.RemoveAll(outputPath); err != nil {
		fmt.Println("Error creating folder:", err)
		return
	}

	// Create folder if it doesn't exist
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		err := os.MkdirAll(outputPath, 0755)
		if err != nil {
			fmt.Println("Error creating folder:", err)
			return
		}
	}

	// Create or overwrite file
	file, err := os.Create(filePath)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	// Write content to file
	_, err = file.WriteString(fileHeader)
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return
	}

	hashes := []hashed{}

	err = filepath.Walk(staticFiles, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// If it's a directory, skip it
		if info.IsDir() {
			return nil
		}

		// If it's a file, copy it to the destination
		if !info.Mode().IsRegular() {
			// Skip special files
			return nil
		}

		extend := ""
		for _, ext := range extentions {
			if strings.HasSuffix(path, ext) {
				extend = ext
				break
			}
		}

		if extend != "" {
			fileName := strings.TrimSuffix(filepath.Base(path), extend) + "-" + hashFile(path) + extend
			dstPath := filepath.Join(outputPath, fileName)
			hashes = append(hashes, hashed{
				fileName: filepath.Base(path),
				path:     fileName,
			})
			fmt.Printf("Copying CSS file: %s\n", path)
			return copyFile(path, dstPath)
		}

		fileName := filepath.Base(path)
		dstPath := filepath.Join(outputPath, fileName)
		fmt.Printf("Copying file: %s\n", path)
		return copyFile(path, dstPath)
	})
	if err != nil {
		fmt.Println(err)
	}

	for _, h := range hashes {
		_, err = file.WriteString(makeConstant(h))
		if err != nil {
			fmt.Println("Error writing to file:", err)
			return
		}

	}

}

func hashFile(path string) string {
	file, err := os.Open(path)
	if err != nil {
		os.Exit(1)
	}
	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		os.Exit(1)
	}
	sum := hash.Sum(nil)

	return hex.EncodeToString(sum)[:12]
}

func makeConstant(hash hashed) string {
	parts := strings.Split(hash.fileName, ".")
	var name string
	for _, part := range parts {
		name += cases.Title(language.Und, cases.NoLower).String(part)
	}
	name = strings.ReplaceAll(name, "-", "")

	path := "/static/" + hash.path

	return fmt.Sprintf("const %s string = \"%s\"\n", name, path)
}

func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	if filepath.Ext(src) == ".css" {
		m := minify.New()
		m.AddFunc("text/css", css.Minify)
		err := m.Minify("text/css", dstFile, srcFile)
		if err != nil {
			panic(err)
		}
	} else {
		_, err = io.Copy(dstFile, srcFile)
		if err != nil {
			return err
		}
	}

	return nil
}
